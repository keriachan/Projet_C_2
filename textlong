Le C est un langage de programmation procédural et généraliste. Il est qualifié de langage de bas niveau dans le sens où chaque instruction du langage est conçue pour être compilée en un nombre d'instructions machine assez prévisible en termes d'occupation mémoire et de charge de calcul. En outre, il propose un éventail de types entiers et flottants conçus pour pouvoir correspondre directement aux types de donnée utilisés par le processeur. Enfin, il fait un usage intensif des calculs d'adresse mémoire avec la notion de pointeur.
Hormis les types de base, C supporte les types énumérés, composés, et opaques. Il ne propose en revanche aucune opération qui traite directement des objets de plus haut niveau (fichier informatique, chaîne de caractères, liste, table de hachage…). Ces types plus évolués doivent être traités en manipulant des pointeurs et des types composés. De même, le langage ne propose pas en standard la gestion de la programmation orientée objet, ni de système de gestion d'exceptions. Il existe des fonctions standards pour gérer les entrées-sorties et les chaînes de caractères, mais contrairement à d'autres langages, aucun opérateur spécifique pour améliorer l'ergonomie. Ceci rend aisé le remplacement des fonctions standards par des fonctions spécifiquement conçues pour un programme donné.
Ces caractéristiques en font un langage privilégié quand on cherche à maîtriser les ressources matérielles utilisées, le langage machine et les données binaires générées par les compilateurs étant relativement prévisibles. Ce langage est donc extrêmement utilisé dans des domaines comme la programmation embarquée sur microcontrôleurs, les calculs intensifs, l'écriture de systèmes d'exploitation et les modules où la rapidité de traitement est importante. Il constitue une bonne alternative au langage d'assemblage dans ces domaines, avec les avantages d'une syntaxe plus expressive et de la portabilité du code source. Le langage C a été inventé pour écrire le système d'exploitation Unix, et reste utilisé pour la programmation système. Ainsi le noyau de grands systèmes d'exploitation comme Windows et Linux sont développés en grande partie en C.
En contrepartie, la mise au point de programmes en C, surtout s'ils utilisent des structures de données complexes, est plus difficile qu'avec des langages de plus haut niveau. En effet, dans un souci de performance, le langage C impose à l'utilisateur de programmer certains traitements (libération de la mémoire, vérification de la validité des indices sur les tableaux…) qui sont pris en charge automatiquement dans les langages de haut niveau.
Dépouillé des commodités apportées par sa bibliothèque standard, C est un langage simple, et son compilateur l'est également. Cela se ressent au niveau du temps de développement d'un compilateur C pour une nouvelle architecture de processeur : Kernighan et Ritchie estimaient qu'il pouvait être développé en deux mois car « on s'apercevra que les 80 % du code d'un nouveau compilateur sont identiques à ceux des codes des autres compilateurs existant déjà. »
Le langage C comprend de nombreux types de nombres entiers, occupant plus ou moins de bits. La taille des types n'est que partiellement standardisée : le standard fixe uniquement une taille minimale et une magnitude minimale. Les magnitudes minimales sont compatibles avec d'autres représentations binaires que le complément à deux, bien que cette représentation soit presque toujours utilisée en pratique. Cette souplesse permet au langage d'être efficacement adapté à des processeurs très variés, mais elle complique la portabilité des programmes écrits en C.
Chaque type entier a une forme « signée » pouvant représenter des nombres négatifs et positifs, et une forme « non signée » ne pouvant représenter que des nombres naturels. Les formes signées et non signées doivent avoir la même taille.
Le type le plus commun est int, il représente le mot machine.
Contrairement à de nombreux autres langages, le type char est un type entier comme un autre, bien qu'il soit généralement utilisé pour représenter les caractères. Sa taille est par définition d'un byte.
Les comportements non spécifiés sont similaires aux comportements définis par l'implémentation, mais le comportement adopté par l'implémentation n'a pas à être documenté. Il n'a même pas à être le même en toutes circonstances. Néanmoins, le programme reste correct, le programmeur ne peut juste pas compter sur une règle particulière.
Par exemple, l'ordre d'évaluation des paramètres lors d'un appel de fonction n'est pas spécifié. Le compilateur peut même choisir d'évaluer dans un ordre différent les paramètres de deux appels à la même fonction, si ça peut aider son optimisation.
La norme C définit certains cas où des constructions syntaxiquement valides ont un comportement indéfini. Selon la norme, tout peut alors arriver : la compilation peut échouer, ou produire un exécutable dont l'exécution sera interrompue, ou qui produira des résultats faux, ou même qui donnera l'apparence de fonctionner sans erreur. Lorsqu'un programme contient un comportement indéfini, c'est le comportement de l'ensemble du programme qui devient indéfini, pas seulement le comportement de l'instruction contenant l'erreur. Ainsi, une instruction erronée peut corrompre des données qui seront traitées bien plus tard, reportant d'autant la manifestation de l'erreur. Et même sans être exécutée, une instruction erronée peut amener le compilateur à réaliser des optimisations sur la base d'hypothèses fausses, produisant un exécutable qui ne fait pas du tout ce qui est prévu. 
On pourrait ainsi penser que dans cet exemple i pourrait valoir 4 ou 5 suivant le choix du compilateur, mais il pourrait tout aussi bien valoir 42 ou l'affectation pourrait arrêter l'exécution, ou le compilateur peut refuser la compilation. Aucune garantie n'existe dès qu'un comportement indéfini existe.
Pour ne citer que quelques exemples, le déréférencement d'un pointeur nul, tout accès à un tableau hors de ses limites, l'utilisation d'une variable non initialisée ou encore le débordement d'entiers signés ont tous des comportements indéfinis. Le compilateur peut utiliser le fait qu'une construction est indéfinie dans certains cas pour supposer que ce cas ne se produit jamais et optimiser plus agressivement le code. Si l'exemple ci-dessus peut paraître évident, certains exemples complexes peuvent être bien plus subtils et être source de bugs parfois graves.
En apparence, ce code est prudent et effectue les vérifications de sécurité nécessaires pour ne pas déborder du buffer alloué. En pratique, les versions récentes de compilateurs tels que GCC, Clang ou Microsoft Visual C++ peuvent supprimer le second test, et rendre possibles des débordements. En effet, la norme précise que l'arithmétique de pointeur sur un objet ne peut donner un pointeur hors de cet objet. Le compilateur peut donc décider que le test est toujours faux et le supprimer.
En 2008, quand les développeurs de GCC ont modifié le compilateur pour qu'il optimise certaines vérifications de débordement qui reposaient sur des comportements indéfinis, le CERT a émis un avertissement sur l'utilisation des versions récentes de GCC. Ces optimisations sont en fait présentes dans la plupart des compilateurs modernes, le CERT a révisé son avertissement dans ce sens.
Certains outils existent pour détecter ces constructions problématiques, et les meilleurs compilateurs en décèlent certaines (il faut parfois activer des options particulières) et peuvent les signaler, mais aucun ne prétend à l'exhaustivité.
En 1983, l'Institut national américain de normalisation (ANSI) a formé un comité de normalisation (X3J11) du langage qui a abouti en 1989 à la norme dite ANSI C ou C89 (formellement ANSI X3.159-1989). En 1990, cette norme a également été adoptée par l'Organisation internationale de normalisation (C90, C ISO, formellement ISO/CEI 9899:1990). ANSI C est une évolution du C K&R qui reste extrêmement compatible. Elle reprend quelques idées de C++, notamment la notion de prototype et les qualificateurs de type.
Entre 1994 et 1996, le groupe de travail de l'ISO (ISO/CEI JTC1/SC22/WG14) a publié deux correctifs et un amendement à C90 : ISO/CEI 9899/COR1:1994 Technical Corrigendum 1, ISO/CEI 9899/AMD1:1995 Intégrité de C et ISO/CEI 9899/COR1:1996 Technical Corrigendum 2. Ces changements assez modestes sont parfois appelés C89 avec amendement 1, ou C94 / C95. Trois fichiers d'entêtes ont été ajoutés, dont deux concernant les caractères larges et un autre définissant un certain nombre de macros en rapport avec la norme de caractères ISO 646.
En 1999, une nouvelle évolution du langage est normalisée par l'ISO : C99 (formellement ISO/CEI 9899:1999). Les nouveautés portent notamment sur les tableaux de taille variable, les pointeurs restreints, les nombres complexes, les littéraux composés, les déclarations mélangées avec les instructions, les fonctions inline, le support avancé des nombres flottants, et la syntaxe de commentaire de C++. La bibliothèque standard du C a été enrichie de six fichiers d'en-tête depuis la précédente norme.
En 2011, l'ISO ratifie une nouvelle version du standard : C11, formellement ISO/CEI 9899:2011. Cette évolution introduit notamment le support de la programmation multi-thread, les expressions à type générique, et un meilleur support d'Unicode.
En 2018, l'ISO ratifie une nouvelle version : formellement ISO/CEI 9899:2018, connue aussi comme C18 ou C17. Cette évolution s'attache à préciser et corriger les points litigieux, et n'introduit aucune nouveauté fonctionnelle.
En octobre 2024, l'ISO a publié une nouvelle norme ISO/CEI 9899:2024 ou plus simplement C23. 